---
import Button from "@/components/ui/button/button.astro";
import { ArrowLeft, ArrowRight } from "@lucide/astro";
import Review from "./Review.astro";
import { useTranslations } from "@/lib/i18n";
import { ui } from "@/i18n/ui";

const {
  title,
  reviews = [],
  lang = "fr",
} = Astro.props as { title: string; reviews: any[]; lang?: keyof typeof ui };
const t = useTranslations(lang);

const MIN_ITEMS_FOR_SCROLL = 10;
const BUFFER_SIZE = 4;

let workingReviews = [...reviews];
while (
  workingReviews.length > 0 &&
  workingReviews.length < MIN_ITEMS_FOR_SCROLL
) {
  workingReviews = [...workingReviews, ...reviews];
}

const tailBuffer = workingReviews.slice(-BUFFER_SIZE);
const headBuffer = workingReviews.slice(0, BUFFER_SIZE);
const displayReviews = [...tailBuffer, ...workingReviews, ...headBuffer];

const itemCount = workingReviews.length;
const bufferSize = tailBuffer.length;
---

<section
  class="relative mt-24 grid gap-10 px-4 sm:px-6 md:mt-48 md:gap-20 md:px-10 lg:px-20"
>
  <div class="grid w-full items-center justify-between sm:flex">
    <h2>{title}</h2>
    <div class="flex-none place-self-end">
      <Button
        onclick="window.scrollCarousel(-1)"
        variant="ghost"
        class="touch-manipulation"
        aria-label={t("home.reviews.previous")}
      >
        <ArrowLeft />
      </Button>
      <Button
        onclick="window.scrollCarousel(1)"
        variant="ghost"
        class="touch-manipulation"
        aria-label={t("home.reviews.next")}
      >
        <ArrowRight />
      </Button>
    </div>
  </div>
  <div class="review-carousel-container overflow-hidden">
    <div
      id="review-carousel"
      class="no-scrollbar grid snap-x snap-mandatory auto-cols-[calc(100%)] grid-flow-col gap-6 overflow-x-auto scroll-smooth md:auto-cols-[calc(33.333%-1rem)]"
      style="scrollbar-width: none;"
      data-item-count={itemCount}
      data-buffer-size={bufferSize}
      tabindex="0"
      role="region"
      aria-label={t("home.reviews.title")}
    >
      {
        displayReviews.map((review, index) => (
          <div class="snap-start">
            <Review review={review} index={index} />
          </div>
        ))
      }
    </div>
  </div>
</section>

<script>
  function initCarousel() {
    const carousel = document.getElementById("review-carousel");

    if (carousel) {
      const SCROLL_DEBOUNCE = 100;
      const SCROLL_THRESHOLD = 5;
      const TRANSITION_DELAY = 10;

      let scrollTimeout: number | null = null;
      let itemWidth: number;

      const itemCount = parseInt(carousel.dataset.itemCount || "0");
      const bufferSize = parseInt(carousel.dataset.bufferSize || "0");

      const calculateDimensions = () => {
        if (carousel.children.length === 0) return;

        if (carousel.children.length > 1) {
          const first = carousel.children[0].getBoundingClientRect();
          const second = carousel.children[1].getBoundingClientRect();
          itemWidth = second.left - first.left;
        } else {
          itemWidth = carousel.children[0].getBoundingClientRect().width;
        }

        if (carousel.scrollLeft === 0 && bufferSize > 0) {
          carousel.scrollLeft = itemWidth * bufferSize;
        }
      };

      const resetScroll = (targetPosition: number) => {
        carousel.style.scrollBehavior = "auto";
        requestAnimationFrame(() => {
          carousel.scrollLeft = targetPosition;
          setTimeout(() => {
            carousel.style.scrollBehavior = "smooth";
          }, TRANSITION_DELAY);
        });
      };

      const handleInfiniteScroll = () => {
        const { scrollLeft, scrollWidth, clientWidth } = carousel;

        const realSetWidth = itemWidth * itemCount;
        if (scrollLeft <= SCROLL_THRESHOLD) {
          resetScroll(scrollLeft + realSetWidth);
        } else if (scrollLeft >= scrollWidth - clientWidth - SCROLL_THRESHOLD) {
          resetScroll(scrollLeft - realSetWidth);
        }
      };

      carousel.addEventListener("scroll", () => {
        if (scrollTimeout) clearTimeout(scrollTimeout);
        scrollTimeout = window.setTimeout(
          handleInfiniteScroll,
          SCROLL_DEBOUNCE,
        );
      });

      requestAnimationFrame(() => {
        calculateDimensions();
      });

      if ("ResizeObserver" in window) {
        const resizeObserver = new ResizeObserver(() => {
          calculateDimensions();
        });
        resizeObserver.observe(carousel);
      } else {
        (globalThis as any).addEventListener("resize", calculateDimensions);
      }

      (globalThis as any).scrollCarousel = (direction: number) => {
        const scrollAmount = itemWidth * direction;
        carousel.scrollBy({ left: scrollAmount, behavior: "smooth" });
      };

      // Keyboard navigation for carousel
      carousel.addEventListener("keydown", (e: KeyboardEvent) => {
        if (e.key === "ArrowLeft") {
          e.preventDefault();
          (globalThis as any).scrollCarousel(-1);
        } else if (e.key === "ArrowRight") {
          e.preventDefault();
          (globalThis as any).scrollCarousel(1);
        }
      });
    }
  }

  initCarousel();
  document.addEventListener("astro:page-load", initCarousel);
</script>
