---
import Layout from "@/layouts/Layout.astro";
import ActivitiesSection from "@/components/ActivitiesSection.astro";
import RestaurantsSection from "@/components/RestaurantsSection.astro";
import { useTranslations, getLocalizedUrl } from "@/lib/i18n";
import { surroundings } from "@/constants/surroundings";
import businessHours from "@/constants/businessHours.json";
import { languages } from "@/i18n/ui";
import { Bike } from "@lucide/astro";

const { lang } = Astro.props as { lang: keyof typeof languages };
const t = useTranslations(lang);

type TranslationKey = Parameters<typeof t>[0];
const toKey = (key: string) => key as TranslationKey;

const ITEMS_PER_PAGE = 6;

// Function to check if a restaurant is open at a specific time
const isOpenAtTime = (
  slug: string,
  startHour: number,
  endHour: number,
): boolean => {
  const toBusinessHoursKey = (slug: string) => {
    return slug.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
  };

  const businessHoursKey = toBusinessHoursKey(slug);
  const hours =
    businessHours[businessHoursKey as keyof typeof businessHours]?.hours;

  if (!hours) return false;

  // Get today's day of week (0 = Sunday, so we need to adjust)
  const now = new Date();
  const dayOfWeek = now.getDay();
  const dayNames = [
    "sunday",
    "monday",
    "tuesday",
    "wednesday",
    "thursday",
    "friday",
    "saturday",
  ];
  const todayName = dayNames[dayOfWeek];

  const todayHours = hours[todayName as keyof typeof hours];

  if (!todayHours?.isOpen || !("periods" in todayHours)) {
    return false;
  }

  // Check if any period overlaps with the requested time window
  // The requested time window is [startHour, endHour)
  return todayHours.periods!.some((period: { open: string; close: string }) => {
    const openHour =
      parseInt(period.open.slice(0, 2)) + parseInt(period.open.slice(2)) / 60;
    const closeHour =
      parseInt(period.close.slice(0, 2)) + parseInt(period.close.slice(2)) / 60;

    // Check if the period overlaps with the requested time window
    // Overlap occurs if: period.open < endHour AND period.close > startHour
    return openHour < endHour && closeHour > startHour;
  });
};

const isOpenNoon = (slug: string): boolean => {
  return isOpenAtTime(slug, 12, 14);
};

const isOpenEvening = (slug: string): boolean => {
  return isOpenAtTime(slug, 19, 22);
};

const formatCard = (
  item:
    | (typeof surroundings.toVisit)[number]
    | (typeof surroundings.toEat)[number],
) => {
  const categories = (item as { category?: string[] }).category ?? [];
  const firstImage = item.gallery?.[0];
  const bikeRoute = (item as { bikeRoute?: { tag?: string } }).bikeRoute;

  // Build tags array: categories + bike tag if exists
  const allTags: { icon?: any; text: string }[] = [
    ...categories.map((cat) => ({
      text: t(toKey(`surroundings.category.${cat}`)),
    })),
  ];

  // Add bike route tag if it exists
  if (bikeRoute?.tag) {
    allTags.push({
      icon: Bike,
      text: t(toKey(`surroundings.tags.${bikeRoute.tag}`)),
    } as { icon: any; text: string });
  }

  return {
    key: item.slug,
    title: item.title,
    image: firstImage?.src,
    imageAlt: t(toKey(firstImage?.altKey ?? "")),
    description: item.shortDesc ? t(toKey(item.shortDesc)) : undefined,
    tags: allTags,
    categories,
    buttonText: t("surroundings.card.cta"),
    buttonLink: getLocalizedUrl("surrounding", lang, item.slug),
  };
};

const activities = surroundings.toVisit.map(formatCard);

// Add dynamic filter properties to restaurants
const restaurantFiltersData = surroundings.toEat.map((item) => {
  const baseCard = formatCard(item);
  const openNoon = isOpenNoon(item.slug);
  const openEvening = isOpenEvening(item.slug);

  const dynamicCategories = [...(item.category ?? [])];
  if (openNoon) dynamicCategories.push("openNoon");
  if (openEvening) dynamicCategories.push("openEvening");

  return {
    ...baseCard,
    categories: dynamicCategories,
    openNoon,
    openEvening,
  };
});

const allCategories = [
  ...new Set(surroundings.toVisit.flatMap((item) => item.category ?? [])),
].sort();

const restaurantCategories = [
  ...new Set([
    ...restaurantFiltersData.flatMap((item) => item.categories),
    "openNoon",
    "openEvening",
  ]),
].sort();

const getTotalPages = (count: number) =>
  Math.max(1, Math.ceil(count / ITEMS_PER_PAGE));
const activitiesTotalPages = getTotalPages(activities.length);
const restaurantsTotalPages = getTotalPages(restaurantFiltersData.length);
---

<Layout
  title={t("seo.pages.surroundings.title")}
  description={t("seo.pages.surroundings.description")}
>
  <div
    data-scroll-animated
    class="bg-background sticky top-0 z-10 ml-[calc(50%-50vw)] h-28 w-screen"
  >
  </div>
  <div class="px-4 pt-12 sm:px-6 md:px-10 md:pt-24 lg:px-20">
    <h1>{t("surroundings.hero.title")}</h1>
    <p class="mt-12 max-w-4xl md:w-4/5">{t("surroundings.hero.text")}</p>
  </div>

  <ActivitiesSection
    activities={activities}
    categories={allCategories}
    totalPages={activitiesTotalPages}
  />

  <RestaurantsSection
    restaurants={restaurantFiltersData}
    categories={restaurantCategories}
    totalPages={restaurantsTotalPages}
  />
</Layout>

<script>
  import { initializeFilterSystem } from "@/lib/filterSystem";

  // Initialize the filter system when DOM is ready
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initializeFilterSystem);
  } else {
    initializeFilterSystem();
  }
</script>
